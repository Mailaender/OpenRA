#region Copyright & License Information
/*
 * Copyright 2007-2018 The OpenRA Developers (see AUTHORS)
 * This file is part of OpenRA, which is free software. It is made
 * available to you under the terms of the GNU General Public License
 * as published by the Free Software Foundation, either version 3 of
 * the License, or (at your option) any later version. For more
 * information, see COPYING.
 */
#endregion

using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using MoonSharp.Interpreter;

namespace OpenRA.Scripting
{
	public class ScriptMemberWrapper
	{
		public readonly object Target;
		public readonly MemberInfo Member;

		public readonly bool IsMethod;
		public readonly bool IsGetProperty;
		public readonly bool IsSetProperty;

		public ScriptMemberWrapper(ScriptContext context, object target, MemberInfo mi)
		{
			Target = target;
			Member = mi;

			var property = mi as PropertyInfo;
			if (property != null)
			{
				IsGetProperty = property.GetGetMethod() != null;
				IsSetProperty = property.GetSetMethod() != null;
			}
			else
				IsMethod = true;
		}

		object Invoke(DynValue[] args)
		{
			object[] clrArgs = null;
			try
			{
				if (!IsMethod)
					throw new ScriptRuntimeException("Trying to invoke a ScriptMemberWrapper that isn't a method!");

				var mi = (MethodInfo)Member;
				var pi = mi.GetParameters();

				clrArgs = new object[pi.Length];

				var argLength = args.Length;
				for (var i = 0; i < pi.Length; i++)
				{
					if (i >= argLength)
					{
						if (!pi[i].IsOptional)
							throw new ScriptRuntimeException("Argument '{0}' of '{1}' is not optional.".F(pi[i].LuaDocString(), Member.LuaDocString()));

						clrArgs[i] = pi[i].DefaultValue;
						continue;
					}
				}

				return mi.Invoke(Target, clrArgs);
			}
			finally
			{
				// If we created any arrays of LuaValues to pass around, we need to dispose those too.
				if (clrArgs != null)
				{
					foreach (var arg in clrArgs)
					{
						if (!(arg is DynValue[]))
							continue;
					}
				}
			}
		}

		public DynValue Get(Script runtime)
		{
			if (IsMethod)
				return DynValue.FromObject(runtime, (Func<DynValue[], object>)Invoke);

			if (IsGetProperty)
				return DynValue.FromObject(runtime, ((PropertyInfo)Member).GetValue(Target, null));

			throw new ScriptRuntimeException("The property '{0}' is write-only".F(Member.Name));
		}

		public void Set(Script runtime, DynValue value)
		{
			if (IsSetProperty)
			{
				var pi = (PropertyInfo)Member;
				object clrValue = value.UserData.Object;

				pi.SetValue(Target, clrValue, null);
			}
			else
				throw new ScriptRuntimeException("The property '{0}' is read-only".F(Member.Name));
		}

		public static IEnumerable<MemberInfo> WrappableMembers(Type t)
		{
			// Only expose defined public non-static methods that were explicitly declared by the author
			var flags = BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly;
			return t.GetMembers(flags).Where(mi =>
			{
				// Properties are always wrappable
				if (mi is PropertyInfo)
					return true;

				// Methods are allowed if they aren't generic, and aren't generated by the compiler
				var method = mi as MethodInfo;
				if (method != null && !method.IsGenericMethodDefinition && !method.IsSpecialName)
					return true;

				// Fields aren't allowed
				return false;
			});
		}
	}
}
